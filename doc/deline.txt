*Deline*    A lightweight statusline plugin with construction functionality. 


==============================================================================
VARIABLES                                                   *deline-variables*

                                                 *g:Deline_DefaultDefinitions*
g:Deline_DefaultDefinitions = 1
                if non-zero, define statusline by deline's settings.


==============================================================================
FUNCTIONS                                                   *deline-functions*

USAGE                           DESCRIPTION~

Deline({list})                  Define |'statusline'| with |deline-functions|.
DelineConfig({config})          Configure Deline settings.
deline#argpos()                 %a
deline#bar()                    |
deline#bufnr()                  %n
deline#char()                   %b
deline#charhex()                %B
deline#column()                 %c
deline#columnv()                %v
deline#columnvoptional()        %V
deline#comment({text})          comment (simply ignored as statusline)
deline#expr({expr})             evaluated vim expr
deline#file({fmt})              file name
deline#fileencoding()           &fileencoding
deline#fileformat()             &fileformat
deline#filehead({filepath}, {interval})
                                displays the first line of the {filepath} at {inteerval}.
deline#filetail({filepath}, {interval})
                                displays the last line of the {filepath} at {inteerval}.
deline#filetype()               &filetype
deline#helpfile()               %h
deline#hl({hlname})             change highlight {hlname}.
deline#if({expr}, {t}, {f})     evaluates {expr} and returns {t} or {f}
deline#keymap()                 %k
deline#line()                   %l
deline#linepercent()            %p
deline#mode()                   the name of mode 'NORMAL', ...
deline#modeHL({hlname})         re-define highlight as {hlname}
deline#modified({t}, {f})       returns {t} if &modified, else {f}
deline#notsaved({min_ago})      displays delta time from last save. 
deline#numlines()               %L
deline#offset()                 %o
deline#offsethex()              %O
deline#page()                   %N
deline#preview()                %w
deline#quickfix()               %q
deline#readonly({t}, {f})       returns {t} if &readonly, else {f}
deline#rightalign()             %=
deline#space()                  ' '
deline#strftime({fmt})          |strftime()|
deline#system({cmd})            |system()|
deline#winpercent()             %P
deline#extra#weatherhacks({url}, {interval})
                                 fetch & displays weather info from weatherhacks site. 
deline#dynamic#cyclic({list})   elem of {list} one by one
deline#dynamic#expr({expr})     returns {expr} dynamically.
deline#dynamic#if({expr}, {t}, {f})
                                if eval({expr}) then {t} else {f}
deline#dynamic#periodic({period})
                                defines {period} by millisecond.

                                                                    *Deline()*
Deline({list})
                Example: >
                    call Deline([
                        \ "mode:",
                        \ deline#mode(),
                        \ deline#rightalign(),
                        \ deline#modified('+ ', ''),
                        \ deline#file(':p:h:t/:p:t'),
                        \ ])
<
                    ______________________________________ 
                    mode:NORMAL         + mydir/myfile.txt 
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

                                                              *DelineConfig()*
DelineConfig({config})
                Example: >
                    call DelineConfig({
                        \ "no_name": "*NAME_NOT_DEFINED*",
                        \
                        \ "mode_c": {
                        \ "": " COMMAND ",
                        \ "guifg": "#000000",
                        \ "guibg": "#ffffff",
                        \ },
                        \ })
<
                
                KEY		DESCRIPTION ~
                
                hl_1		highlight group User1: textual part
                hl_3		highlight group User3: separator
                hl_4		highlight group User4: cautious
                hl_mode_	highlight group User2: mode `"hl_mode_" . mode()`
                no_name		fallback name of |deline#file()|
                		default: [No Name]
                interval	throttling interval of re-evaluating of
                		dynamic functions in second.
                		default: 0.5

                                                           *deline#notsaved()*
deline#notsaved({min_ago})
                Returns duration from last save in "{hour}h{minute}m" format.
                {min_ago} is a Number to suppress output if the duration(in minute) < {min_ago}. 

                                                 *deline#extra#weatherhacks()*
deline#extra#weatherhacks({url}, {interval})
                 Tokyo: http://weather.livedoor.com/weather_hacks/ical

                                                     *deline#dynamic#cyclic()*
deline#dynamic#cyclic({list})
                {list} is a list of text.
                Changes texts one by one on every evaluation.
                
                Example: >
                    call Deline([
                        \ deline#dynamic#cyclic(["a", "b", "c"]),
                        \ ])
<
                        * moving cursor ...
                        ______________________________________ 
                        a
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                        ______________________________________ 
                        b
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                        ______________________________________ 
                        c
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                        ______________________________________ 
                        a
                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

                                                       *deline#dynamic#expr()*
deline#dynamic#expr({expr})
                {expr} is a string of Vim expression like function call.
                Unlike |deline#expr()|, this function does not return string to be
                passed to statusline. This returns an object that holds "return the
                result of evaluation".
                
                Example: >
                	call Deline([
                	    \ deline#comment("(1)"),
                	    \ deline#dynamic#expr("strftime('%T')"),
                	    \ 
                	    \ deline#comment("(2)"),
                	    \ deline#expr("strftime('%T')"),
                	    \ ])
<
                	(1) At EVERY evaluation of statusline, dynamically returns the
                	    result of strftime('%T').
                	(2) At ONCE, returns the result of strftime('%T').

                                                         *deline#dynamic#if()*
deline#dynamic#if({expr}, {t}, {f})
                Dynamically returns {t} or {f} by eval({expr}).

                                                   *deline#dynamic#periodic()*
deline#dynamic#periodic({period})
                Start timer so that |deline-dynamic-functions| are called periodicaly.
                Non-dynamic functions are not in effect by this function.
                
                Without calling this function, all dynamic functions are only
                evaluated as statusline is evaluated.
                (Moving cursor, changing mode, ...)
                
                Example1: >
                    call Deline([
                        \ deline#comment("(1)"),
                        \ deline#dynamic#periodic(100),
                        \
                        \ deline#comment("(2)"),
                        \ deline#dynamic#expr("strftime('%T')"),
                        \
                        \ deline#comment("(3)"),
                        \ deline#expr("strftime('%T')"),
                        \ ])
<
                    (1) Declare period is 100ms.
                    (2) Dynamic expr is evaluated every period.
                    (3) This non-dynamic expr is evaluated once before call
                        Deline().
                
                Example2: >
                    call Deline([
                        \ deline#comment("(1) NO deline#dynamic#periodic()"),
                
                        \ deline#comment("(2)"),
                        \ deline#dynamic#expr("strftime('%T')"),
                        \
                        \ deline#comment("(3)"),
                        \ deline#expr("strftime('%T')"),
                        \ ])
<
                    (1) NO deline#dynamic#periodic().
                    (2) Dynamic expr is evaluated every re-evaluation of
                        statusline.
                    (3) This non-dynamic expr is evaluated once before call
                        Deline().

 vim: set noet ft=help sts=8 sw=8 ts=8 tw=78:
