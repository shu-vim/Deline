*Deline*    A lightweight statusline plugin with construction functionality. 

1. Deline() function				|Deline()|
2. Construction functions			|deline-functions|
2.1. Dynamic functions				|deline-dynamic-functions|
3. Configuration				|deline-configuration|

==============================================================================
1. Deline() function						*Deline()*

Deline({list})
		Define |'statusline'| with |deline-functions| and
		|deline-dynamic-functions|.

		Example: >
			call Deline([
				\ "mode:",
				\ deline#mode(),
				\ deline#rightalign(),
				\ deline#modified('+ ', ''),
				\ deline#file(':p:h:t/:p:t'),
				\ ])
<			______________________________________ 
			mode:NORMAL         + mydir/myfile.txt 
			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

==============================================================================
2. Construction functions				*deline-functions*

FUNCTION			DESCRIPTION ~

deline#argpos()			%a
deline#bar()			|
deline#bufnr()			%n
deline#char()			%b
deline#charhex()		%B
deline#column()			%c
deline#columnv()		%v
deline#columnvoptional()	%V
deline#comment({text})		comment (simply ignored as statusline)
deline#expr({expr})		evaluated vim expr
deline#file({fmt})		file name
deline#fileencoding()		&fileencoding
deline#fileformat()		&fileformat
deline#filetype()		&filetype
deline#helpfile()		%h
deline#hl({hlname})		change highlight {hlname}
deline#if({expr}, {t}, {f})	evaluate {expr} and return {t} or {f}
deline#keymap()			%k
deline#line()			%l
deline#linepercent()		%p
deline#mode()			the name of mode 'NORMAL', ...
deline#modeHL({name})		re-define highlight as {hlname}
deline#modified({t}, {f})	return {t} if &modified, else {f}
deline#notsaved|({min})    displays delta time from last save. 
deline#numlines()		%L
deline#offset()			%o
deline#offsethex()		%O
deline#page()			%N
deline#preview()		%w
deline#quickfix()		%q
deline#readonly({t}, {f})	return {t} if &readonly, else {f}
deline#rightalign()		%=
deline#space()			' '
deline#strftime({fmt})		|strftime()|
deline#system({cmd})		|system()|
deline#winpercent()		%P

						   *deline#notsaved()*
deline#dynamic#notsaved({min})
	Returns duration from last save in "{hour}h{minute}m" format.
	{min} is a Number to suppress output if the duration(in minute) < {min}. 


==============================================================================
2.1. Dynamic functions				*deline-dynamic-functions*

Dynamic functions are invoked on statusline evaluation timing.
(non dynamic functions are invoked on passing Deline())

If you like to change highlight by variable, then you should use dynamic
functions.

FUNCTION			  DESCRIPTION ~

|deline#dynamic#expr|({expr})	  result of eval({expr})

|deline#dynamic#cyclic|({list})	  elem of {list} one by one
|deline#dynamic#if|({expr},{t},{f}) if eval({expr}) then {t} else {f}

|deline#dynamic#periodic|({ms})	  start timer to automatical reload.


						       *deline#dynamic#expr()*
deline#dynamic#expr({expr})
	{expr} is a string of Vim expression like function call.
	Unlike |deline#expr()|, this function does not return string to be
	passed to statusline. This returns an object that holds "return the
	result of evaluation".

	Example: >
		call Deline([
			\ deline#comment("(1)"),
			\ deline#dynamic#expr("strftime('%T')"),
			\ 
			\ deline#comment("(2)"),
			\ deline#expr("strftime('%T')"),
			\ ])
<
		(1) At EVERY evaluation of statusline, dynamically returns the
		    result of strftime('%T').
		(2) At ONCE, returns the result of strftime('%T').

						   *deline#dynamic#periodic()*
deline#dynamic#periodic({ms})
	Start timer so that |deline-dynamic-functions| are called periodicaly.
	Non-dynamic functions are not in effect by this function.

	Without calling this function, all dynamic functions are only
	evaluated as statusline is evaluated.
	(Moving cursor, changing mode, ...)

	Example1: >
		call Deline([
			\ deline#comment("(1)"),
			\ deline#dynamic#periodic(100),
			\
			\ deline#comment("(2)"),
			\ deline#dynamic#expr("strftime('%T')"),
			\
			\ deline#comment("(3)"),
			\ deline#expr("strftime('%T')"),
			\ ])
<
		(1) Declare period is 100ms.
		(2) Dynamic expr is evaluated every period.
		(3) This non-dynamic expr is evaluated once before call
		    Deline().

	Example2: >
		call Deline([
			\ deline#comment("(1) NO deline#dynamic#periodic()"),

			\ deline#comment("(2)"),
			\ deline#dynamic#expr("strftime('%T')"),
			\
			\ deline#comment("(3)"),
			\ deline#expr("strftime('%T')"),
			\ ])
<
		(1) NO deline#dynamic#periodic().
		(2) Dynamic expr is evaluated every re-evaluation of
		    statusline.
		(3) This non-dynamic expr is evaluated once before call
		    Deline().

							 *deline#dynamic#if()*
deline#dynamic#if({expr},{t},{f})
	Dynamically returns {t} or {f} by eval({expr}).

						     *deline#dynamic#cyclic()*
deline#dynamic#cyclic({list})
	{list} is a list of text.
	Changes texts one by one on every evaluation.

	Example: >
		call Deline([
			\ deline#dynamic#cyclic(["a", "b", "c"]),
			\ ])
<
			* moving cursor ...
			______________________________________ 
			a
			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
			______________________________________ 
			b
			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
			______________________________________ 
			c
			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
			______________________________________ 
			a
			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

==============================================================================
3. Configuration				*deline-configuration*

Deline can be configured by calling DelineConfig().

DelineConfig({dict})
	Configure Deline settings.

	Example: >
		call DelineConfig({
			\ "no_name": "*NAME_NOT_DEFINED*",
			\
			\ "mode_c": {
			\ "": " COMMAND ",
			\ "guifg": "#000000",
			\ "guibg": "#ffffff",
			\ },
			\ })

KEY		DESCRIPTION ~

hl_1		highlight group User1: textual part
hl_3		highlight group User3: separator
hl_4		highlight group User4: cautious
hl_mode_	highlight group User2: mode `"hl_mode_" . mode()`
no_name		fallback name of |deline#file()|
		default: [No Name]
interval	throttling interval of re-evaluating of
		|deline-dynamic-functions| in second.
		default: 0.5


/* vim: set noet ft=help sts=8 sw=8 ts=8 tw=78 : */
